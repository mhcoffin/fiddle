syntax = "proto3";

package fiddle;

message MidiEvent {
    uint64 timestamp_samples = 1;
    uint32 channel = 2;
    
    oneof event {
        NoteOn note_on = 3;
        NoteOff note_off = 4;
        ControlChange cc = 5;
        PitchBend pitch_bend = 6;
        ProgramChange program_change = 7;
        Aftertouch aftertouch = 8;
        ChannelPressure channel_pressure = 9;
        SysEx sys_ex = 10;
        Other other = 11;
        TransportEvent transport = 12;
        LoadConfigEvent load_config = 15;
    }

    optional uint64 host_sample_position = 13;

    // MIDI port (1-based). 0 or absent = port 1 (backward compatible).
    uint32 port = 14;

    message LoadConfigEvent {
        string config_path = 1;
    }

    message TransportEvent {
        enum Type {
            START = 0;
            STOP = 1;
        }
        Type type = 1;
        optional uint64 host_sample_position = 2;
    }

    message NoteOn {
        uint32 note_number = 1;
        uint32 velocity = 2;
    }

    message NoteOff {
        uint32 note_number = 1;
        uint32 velocity = 2;
    }

    message ControlChange {
        uint32 controller_number = 1;
        uint32 controller_value = 2;
    }

    message PitchBend {
        uint32 value = 1;
    }

    message ProgramChange {
        uint32 program_number = 1;
    }

    message Aftertouch {
        uint32 note_number = 1;
        uint32 value = 2;
    }

    message ChannelPressure {
        uint32 value = 1;
    }

    message SysEx {
        bytes data = 1;
    }

    message Other {
        string description = 1;
    }
}

/**
 * A "Subnote" represents a chunk of a longer Note.
 * Typically ~1 second long, used for processing and lookahead.
 */
message Subnote {
    uint64 id = 1;
    uint32 note_number = 2;
    uint32 channel = 3;
    uint32 velocity = 4;
    
    // Position relative to the start of the original note (in samples)
    uint64 offset_samples = 5;
    // Duration of this chunk (in samples)
    uint64 duration_samples = 6;
    
    bool is_first = 7;
    bool is_last = 8;
}

/**
 * A higher-level Note object aggregated from MIDI events.
 */
message Note {
    uint64 id = 1;
    uint32 note_number = 2;
    uint32 channel = 3;
    uint32 start_velocity = 4;
    reserved 5;  // was end_velocity (Dorico always sends 64, not useful)
    
    uint64 start_sample = 6;
    uint64 duration_samples = 7;

    map<string, float> notation_dimensions = 8;
    map<string, string> notation_techniques = 9;
    map<string, bool> notation_is_default = 10;

    // Per-CC automation envelopes (CC number â†’ timestamped value changes)
    message AutomationPoint {
        uint64 offset_samples = 1;  // relative to note start
        uint32 value = 2;           // 0-127
    }
    message AutomationLane {
        repeated AutomationPoint points = 1;
    }
    map<uint32, AutomationLane> cc_automation = 11;

    // Which dynamics mode this note uses (from expression map volumeType)
    enum DynamicsMode {
        VELOCITY = 0;   // short notes: dynamics = start_velocity
        CC = 1;         // sustained notes: dynamics = CC1 lane in cc_automation
    }
    DynamicsMode dynamics_mode = 12;

    // MIDI port (1-based, mirrors MidiEvent.port). 0 = port 1.
    uint32 port = 13;
}
